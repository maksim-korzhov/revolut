import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState } from "../../app/store";
import { fetchRates } from "./exchangeAPI";
import currency from "currency.js";
import { getRatedValue } from "../../helpers/converters";

export enum LoadingState {
  IDLE,
  LOADING,
  FAILED,
}

export enum RatesEnum {
  USD = "USD",
  EUR = "EUR",
  RUB = "RUB",
  GBP = "GBP",
}

export interface CurrencyData {
  name: RatesEnum;
  sign: string;
  total: number;
}

export type Wallets = Record<RatesEnum, CurrencyData>;
export interface ExchangeState {
  wallets: Wallets;
  rates: {
    from: RatesEnum;
    to: RatesEnum;
    data: Record<RatesEnum, number>;
    status: LoadingState;
  };
}
export type CurrencyShort = Record<
  RatesEnum,
  Pick<CurrencyData, "name" | "sign" | "total">
>;
export type ExchangeStateShort = Record<RatesEnum, CurrencyShort>;

export const initialState: ExchangeState = {
  wallets: {
    USD: {
      name: RatesEnum.USD,
      sign: "$",
      total: 45.43,
    },
    EUR: {
      name: RatesEnum.EUR,
      sign: "€",
      total: 132.44,
    },
    RUB: {
      name: RatesEnum.RUB,
      sign: "₽",
      total: 10007.43,
    },
    GBP: {
      name: RatesEnum.GBP,
      sign: "£",
      total: 21.1,
    },
  },
  rates: {
    from: RatesEnum.USD,
    to: RatesEnum.USD,
    status: LoadingState.IDLE,
    data: {
      EUR: 0.82,
      RUB: 73.6975,
      GBP: 0.71,
      USD: 1,
    },
  },
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const loadRatesAsync = createAsyncThunk(
  "counter/loadRates",
  async () => {
    const response = await fetchRates();

    if (!response) throw new Error("Can not load rates");
    // The value we return becomes the `fulfilled` action payload
    // return response.data;
    return response;
  }
);

export const exchangeSlice = createSlice({
  name: "exchange",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    exchangeValue: (state, action: PayloadAction<number>) => {
      const [fromWallet, toWallet] = selectFromToWallets({ exchange: state });
      const rate = selectCurrentRate({ exchange: state });

      // Get money from the current "from" wallet
      state.wallets[fromWallet as RatesEnum].total = currency(
        state.wallets[fromWallet as RatesEnum].total
      ).subtract(action.payload).value;

      // Move money to the current from wallet
      state.wallets[toWallet as RatesEnum].total = currency(
        state.wallets[toWallet as RatesEnum].total
      ).add(getRatedValue(rate, action.payload)).value;
    },
    setWallets: (state, action: PayloadAction<[string, string]>) => {
      state.rates.from = action.payload[0] as RatesEnum;
      state.rates.to = action.payload[1] as RatesEnum;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(loadRatesAsync.pending, (state) => {
        state.rates.status = LoadingState.LOADING;
      })
      .addCase(loadRatesAsync.fulfilled, (state, action) => {
        state.rates.status = LoadingState.IDLE;
        state.rates.data = Object.keys(state.wallets).reduce(
          (acc: any, key: string) => {
            if (action.payload[key]) {
              // Fake number to emulate different rates
              const randomMultiplier =
                key === RatesEnum.USD ? 1 : Math.random() * 0.1 + 1;

              acc[key] = action.payload[key] * randomMultiplier;
            }

            return acc;
          },
          {}
        );
      })
      .addCase(loadRatesAsync.rejected, (state, action) => {
        state.rates.status = LoadingState.FAILED;
      });
  },
});

export const { exchangeValue, setWallets } = exchangeSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectFromToWallets = (state: RootState) => {
  const rates = state.exchange.rates;
  return [rates.from, rates.to];
};

// Select base wallets data for the slider
export const selectWallets = ({ exchange }: RootState) => {
  return Object.keys(exchange.wallets).reduce((acc: any, key: string) => {
    const currentWallet = exchange.wallets[key as RatesEnum];
    acc[key as RatesEnum] = {
      name: currentWallet.name,
      sign: currentWallet.sign,
      total: currentWallet.total,
    };

    return acc;
  }, {} as any);
};

/**
 * Function receives convert currency rate from rateFromName currency
 * to the rateToName currency
 * @param rateFromNames
 * @param rateToName
 * @returns
 */
export const selectCurrentRate = ({ exchange }: RootState) => {
  const rateFrom = exchange.rates.from;
  const rateTo = exchange.rates.to;

  if (rateFrom === rateTo) return 1;

  const from = exchange.rates.data[rateFrom as RatesEnum];
  const to = exchange.rates.data[rateTo as RatesEnum];

  return to / from;
};

/** Return loading rate status */
export const selectStatus = ({ exchange }: RootState) => {
  return exchange.rates.status;
};

export default exchangeSlice.reducer;
