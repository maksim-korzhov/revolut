{"version":3,"sources":["features/exchange/exchangeSlice.ts","helpers/converters.ts","features/exchange/exchangeAPI.ts","features/currencyRate/CurrencyRate.tsx","features/currencySlide/CurrencySlide.tsx","features/currencySlider/CurrencySlider.tsx","features/currencyInput/CurrencyInput.tsx","app/hooks.ts","features/exchange/Exchange.tsx","App.tsx","app/store.ts","serviceWorker.ts","index.tsx"],"names":["LoadingState","RatesEnum","getRatedValue","rate","value","currency","multiply","initialState","wallets","USD","name","sign","total","EUR","RUB","GBP","rates","from","to","status","IDLE","data","loadRatesAsync","createAsyncThunk","a","fetch","then","response","json","Error","exchangeSlice","createSlice","reducers","exchangeValue","state","action","selectFromToWallets","exchange","fromWallet","toWallet","selectCurrentRate","subtract","payload","add","setWallets","extraReducers","builder","addCase","pending","LOADING","fulfilled","Object","keys","reduce","acc","key","randomMultiplier","Math","random","rejected","FAILED","actions","selectWallets","currentWallet","rateFrom","rateTo","selectStatus","CurrencyRate","loadingState","fromSign","toSign","currentRate","className","toFixed","CurrencySlide","settings","arrows","dots","easing","infinite","mobileFirst","speed","slidesToShow","slidesToScroll","CurrencySlider","onChange","afterChange","slideNumber","callback","map","renderCurrencySlide","withLimit","maxValue","inputObj","floatValue","CurrencyInput","disabled","prefix","undefined","onValueChange","allowLeadingZeros","allowNegative","decimalScale","isAllowed","thousandSeparator","useAppSelector","useSelector","Exchange","dispatch","useDispatch","React","useState","fromValue","setFromValue","toValue","setToValue","calculateValue","newToValue","useEffect","interval","window","setInterval","clearInterval","current","onClick","App","store","configureStore","reducer","exchangeReducer","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.b89ae625.chunk.js","sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../app/store\";\nimport { fetchRates } from \"./exchangeAPI\";\nimport currency from \"currency.js\";\nimport { getRatedValue } from \"../../helpers/converters\";\n\nexport enum LoadingState {\n  IDLE,\n  LOADING,\n  FAILED,\n}\n\nexport enum RatesEnum {\n  USD = \"USD\",\n  EUR = \"EUR\",\n  RUB = \"RUB\",\n  GBP = \"GBP\",\n}\n\nexport interface CurrencyData {\n  name: RatesEnum;\n  sign: string;\n  total: number;\n}\n\nexport type Wallets = Record<RatesEnum, CurrencyData>;\nexport interface ExchangeState {\n  wallets: Wallets;\n  rates: {\n    from: RatesEnum;\n    to: RatesEnum;\n    data: Record<RatesEnum, number>;\n    status: LoadingState;\n  };\n}\nexport type CurrencyShort = Record<\n  RatesEnum,\n  Pick<CurrencyData, \"name\" | \"sign\" | \"total\">\n>;\nexport type ExchangeStateShort = Record<RatesEnum, CurrencyShort>;\n\nexport const initialState: ExchangeState = {\n  wallets: {\n    USD: {\n      name: RatesEnum.USD,\n      sign: \"$\",\n      total: 45.43,\n    },\n    EUR: {\n      name: RatesEnum.EUR,\n      sign: \"€\",\n      total: 132.44,\n    },\n    RUB: {\n      name: RatesEnum.RUB,\n      sign: \"₽\",\n      total: 10007.43,\n    },\n    GBP: {\n      name: RatesEnum.GBP,\n      sign: \"£\",\n      total: 21.1,\n    },\n  },\n  rates: {\n    from: RatesEnum.USD,\n    to: RatesEnum.USD,\n    status: LoadingState.IDLE,\n    data: {\n      EUR: 0.82,\n      RUB: 73.6975,\n      GBP: 0.71,\n      USD: 1,\n    },\n  },\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\nexport const loadRatesAsync = createAsyncThunk(\n  \"counter/loadRates\",\n  async () => {\n    const response = await fetchRates();\n\n    if (!response) throw new Error(\"Can not load rates\");\n    // The value we return becomes the `fulfilled` action payload\n    // return response.data;\n    return response;\n  }\n);\n\nexport const exchangeSlice = createSlice({\n  name: \"exchange\",\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    exchangeValue: (state, action: PayloadAction<number>) => {\n      const [fromWallet, toWallet] = selectFromToWallets({ exchange: state });\n      const rate = selectCurrentRate({ exchange: state });\n\n      // Get money from the current \"from\" wallet\n      state.wallets[fromWallet as RatesEnum].total = currency(\n        state.wallets[fromWallet as RatesEnum].total\n      ).subtract(action.payload).value;\n\n      // Move money to the current from wallet\n      state.wallets[toWallet as RatesEnum].total = currency(\n        state.wallets[toWallet as RatesEnum].total\n      ).add(getRatedValue(rate, action.payload)).value;\n    },\n    setWallets: (state, action: PayloadAction<[string, string]>) => {\n      state.rates.from = action.payload[0] as RatesEnum;\n      state.rates.to = action.payload[1] as RatesEnum;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(loadRatesAsync.pending, (state) => {\n        state.rates.status = LoadingState.LOADING;\n      })\n      .addCase(loadRatesAsync.fulfilled, (state, action) => {\n        state.rates.status = LoadingState.IDLE;\n        state.rates.data = Object.keys(state.wallets).reduce(\n          (acc: any, key: string) => {\n            if (action.payload[key]) {\n              // Fake number to emulate different rates\n              const randomMultiplier =\n                key === RatesEnum.USD ? 1 : Math.random() * 0.1 + 1;\n\n              acc[key] = action.payload[key] * randomMultiplier;\n            }\n\n            return acc;\n          },\n          {}\n        );\n      })\n      .addCase(loadRatesAsync.rejected, (state, action) => {\n        state.rates.status = LoadingState.FAILED;\n      });\n  },\n});\n\nexport const { exchangeValue, setWallets } = exchangeSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\nexport const selectFromToWallets = (state: RootState) => {\n  const rates = state.exchange.rates;\n  return [rates.from, rates.to];\n};\n\n// Select base wallets data for the slider\nexport const selectWallets = ({ exchange }: RootState) => {\n  return Object.keys(exchange.wallets).reduce((acc: any, key: string) => {\n    const currentWallet = exchange.wallets[key as RatesEnum];\n    acc[key as RatesEnum] = {\n      name: currentWallet.name,\n      sign: currentWallet.sign,\n      total: currentWallet.total,\n    };\n\n    return acc;\n  }, {} as any);\n};\n\n/**\n * Function receives convert currency rate from rateFromName currency\n * to the rateToName currency\n * @param rateFromNames\n * @param rateToName\n * @returns\n */\nexport const selectCurrentRate = ({ exchange }: RootState) => {\n  const rateFrom = exchange.rates.from;\n  const rateTo = exchange.rates.to;\n\n  if (rateFrom === rateTo) return 1;\n\n  const from = exchange.rates.data[rateFrom as RatesEnum];\n  const to = exchange.rates.data[rateTo as RatesEnum];\n\n  return to / from;\n};\n\n/** Return loading rate status */\nexport const selectStatus = ({ exchange }: RootState) => {\n  return exchange.rates.status;\n};\n\nexport default exchangeSlice.reducer;\n","import currency from \"currency.js\";\r\n\r\n/**\r\n * Convert value using the current rate.\r\n * @param rate\r\n * @param value\r\n * @returns\r\n */\r\nexport function getRatedValue(rate: number, value: number) {\r\n  return currency(value).multiply(rate).value;\r\n}\r\n","// A mock function to mimic making an async request for data\nexport function fetchRates() {\n  return fetch(\n    `https://openexchangerates.org/api/latest.json?app_id=48a4f37d75e54e7a8498de71bb20c987`\n  )\n    .then((response) => {\n      return response.json();\n    })\n    .then((response) => {\n      return response.rates;\n    });\n}\n","import React from \"react\";\r\nimport { LoadingState } from \"../exchange/exchangeSlice\";\r\n\r\ninterface IProps {\r\n  data: {\r\n    fromSign: string;\r\n    toSign: string;\r\n    currentRate: number;\r\n  };\r\n  loadingState: LoadingState;\r\n}\r\n\r\nconst CurrencyRate: React.FunctionComponent<IProps> = ({\r\n  loadingState,\r\n  data,\r\n}) => {\r\n  const { fromSign, toSign, currentRate } = data;\r\n\r\n  switch (loadingState) {\r\n    case LoadingState.FAILED:\r\n      return <div className=\"error\">Failed to load currency rates</div>;\r\n\r\n    case LoadingState.LOADING:\r\n      return <div className=\"current-rate\">Loading rates...</div>;\r\n\r\n    default:\r\n      return (\r\n        <div className=\"current-rate\">\r\n          {`${fromSign}1 = ${toSign}${currentRate.toFixed(4)}`}\r\n        </div>\r\n      );\r\n  }\r\n};\r\n\r\nexport default CurrencyRate;\r\n","import * as React from \"react\";\r\n\r\ninterface IProps {\r\n  name: string;\r\n  sign: string;\r\n  value: string;\r\n}\r\n\r\n/**\r\n * Renders wallets data on slides.\r\n * @param param0\r\n * @returns\r\n */\r\nconst CurrencySlide: React.FunctionComponent<IProps> = ({\r\n  name,\r\n  sign,\r\n  value,\r\n}) => {\r\n  return (\r\n    <div className=\"exchange-wrapper\">\r\n      <div className=\"exchange-content\">\r\n        <h3 className=\"exchange-currency\">{name}</h3>\r\n        <p className=\"exchange-inwallet\">{`You have ${sign}${value}`}</p>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CurrencySlide;\r\n","import * as React from \"react\";\r\nimport Slider from \"react-slick\";\r\nimport CurrencySlide from \"../currencySlide/CurrencySlide\";\r\n\r\nimport \"slick-carousel/slick/slick.css\";\r\nimport \"slick-carousel/slick/slick-theme.css\";\r\nimport \"./CurrencySlider.css\";\r\n\r\nimport { RatesEnum, Wallets } from \"../exchange/exchangeSlice\";\r\n\r\nconst settings = {\r\n  arrows: false,\r\n  dots: true,\r\n  easing: \"ease-in-out\",\r\n  infinite: true,\r\n  mobileFirst: true,\r\n  speed: 500,\r\n  slidesToShow: 1,\r\n  slidesToScroll: 1,\r\n};\r\n\r\ninterface IProps {\r\n  current: string;\r\n  wallets: Wallets;\r\n  onChange: Function;\r\n}\r\n\r\n/**\r\n * Helper function. Renders wallets data.\r\n * @param wallet\r\n * @returns\r\n */\r\nconst renderCurrencySlide = ({ name, sign, total }: any) => (\r\n  <div className=\"slider-item\" key={name}>\r\n    <CurrencySlide name={name} sign={sign} value={total} />\r\n  </div>\r\n);\r\n\r\nconst afterChange = (\r\n  wallets: Wallets,\r\n  slideNumber: number,\r\n  callback: Function\r\n) => {\r\n  const currentWalletKey = Object.keys(wallets)[slideNumber];\r\n  const currentWallet = wallets[currentWalletKey as RatesEnum];\r\n  callback(currentWallet.name);\r\n};\r\n\r\n/**\r\n * Renders slides with wallets data.\r\n * @param data\r\n * @returns\r\n */\r\nconst CurrencySlider: React.FunctionComponent<IProps> = ({\r\n  wallets,\r\n  onChange,\r\n}) => {\r\n  return (\r\n    <section className=\"exchange\">\r\n      <Slider\r\n        {...settings}\r\n        afterChange={(slideNumber: number) =>\r\n          afterChange(wallets, slideNumber, onChange)\r\n        }\r\n      >\r\n        {Object.keys(wallets).map((key: string) =>\r\n          renderCurrencySlide(wallets[key as RatesEnum])\r\n        )}\r\n      </Slider>\r\n    </section>\r\n  );\r\n};\r\n\r\nexport default CurrencySlider;\r\n","import * as React from \"react\";\r\nimport NumberFormat, { NumberFormatValues } from \"react-number-format\";\r\n\r\nconst MAX_AT_ONCE = 10000000;\r\nconst withLimit = (maxValue: number) => (inputObj: NumberFormatValues) => {\r\n  const { floatValue } = inputObj;\r\n\r\n  if (floatValue && floatValue > maxValue) return false;\r\n\r\n  return true;\r\n};\r\n\r\ninterface IProps {\r\n  name: string;\r\n  disabled?: boolean;\r\n  maxValue?: number;\r\n  prefix?: string;\r\n  value?: number;\r\n  onChange?: Function;\r\n}\r\n\r\n/**\r\n * Display the input for the currency\r\n * @returns\r\n */\r\nconst CurrencyInput: React.FunctionComponent<IProps> = ({\r\n  name,\r\n  onChange,\r\n  value,\r\n  maxValue = MAX_AT_ONCE,\r\n  disabled = false,\r\n  prefix = \"\",\r\n}) => {\r\n  const settings = {} as any;\r\n  if (value !== undefined) settings.value = value;\r\n  if (onChange !== undefined)\r\n    settings.onValueChange = ({ floatValue }: any) =>\r\n      onChange && onChange(floatValue);\r\n\r\n  return (\r\n    <NumberFormat\r\n      allowLeadingZeros={false}\r\n      allowNegative={false}\r\n      className=\"exchangeValue\"\r\n      decimalScale={2}\r\n      disabled={disabled}\r\n      isAllowed={withLimit(maxValue)}\r\n      name={name}\r\n      prefix={prefix}\r\n      thousandSeparator={true}\r\n      {...settings}\r\n    />\r\n  );\r\n};\r\n\r\nexport default CurrencyInput;\r\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import React from \"react\";\r\nimport CurrencyRate from \"../currencyRate/CurrencyRate\";\r\nimport CurrencySlider from \"../currencySlider/CurrencySlider\";\r\nimport CurrencyInput from \"../currencyInput/CurrencyInput\";\r\nimport { useAppSelector, useAppDispatch } from \"../../app/hooks\";\r\nimport {\r\n  selectFromToWallets,\r\n  selectWallets,\r\n  selectCurrentRate,\r\n  setWallets,\r\n  exchangeValue,\r\n  loadRatesAsync,\r\n  selectStatus,\r\n} from \"./exchangeSlice\";\r\nimport { getRatedValue } from \"../../helpers/converters\";\r\n\r\ninterface IProps {}\r\n\r\nconst Exchange: React.FunctionComponent<IProps> = () => {\r\n  const wallets = useAppSelector(selectWallets);\r\n  const [fromWallet, toWallet] = useAppSelector(selectFromToWallets);\r\n  const fromSign = wallets[fromWallet].sign;\r\n  const toSign = wallets[toWallet].sign;\r\n  const currentRate = useAppSelector(selectCurrentRate);\r\n  const dispatch = useAppDispatch();\r\n  const status = useAppSelector(selectStatus);\r\n\r\n  const [fromValue, setFromValue] = React.useState(0);\r\n  const [toValue, setToValue] = React.useState(0);\r\n\r\n  /**\r\n   * Calculate \"to\" value using the current rate\r\n   * @param value\r\n   */\r\n  const calculateValue = (value: number) => {\r\n    setFromValue(value);\r\n\r\n    if (value) {\r\n      const newToValue = getRatedValue(currentRate, value);\r\n      setToValue(newToValue);\r\n    } else {\r\n      setToValue(value);\r\n    }\r\n  };\r\n\r\n  /* eslint-disable react-hooks/exhaustive-deps */\r\n  /** Load base currency rates */\r\n  React.useEffect(() => {\r\n    dispatch(loadRatesAsync());\r\n\r\n    const interval = window.setInterval(\r\n      () => dispatch(loadRatesAsync()),\r\n      10000\r\n    );\r\n\r\n    return () => window.clearInterval(interval);\r\n  }, []);\r\n\r\n  /** Reset values on from wallet changes */\r\n  React.useEffect(() => {\r\n    setFromValue(0);\r\n    setToValue(0);\r\n  }, [fromWallet]);\r\n\r\n  // /** Calculate values on every wallet changes */\r\n  React.useEffect(() => {\r\n    calculateValue(fromValue);\r\n  }, [currentRate, toWallet, calculateValue]);\r\n\r\n  return (\r\n    <>\r\n      <header className=\"header\">\r\n        <CurrencyRate\r\n          loadingState={status}\r\n          data={{\r\n            fromSign,\r\n            toSign,\r\n            currentRate,\r\n          }}\r\n        />\r\n      </header>\r\n\r\n      <div className=\"slider-container\">\r\n        <CurrencySlider\r\n          wallets={wallets}\r\n          current={fromWallet}\r\n          onChange={(from: string) => dispatch(setWallets([from, toWallet]))}\r\n        />\r\n\r\n        <CurrencyInput\r\n          maxValue={wallets[fromWallet].total}\r\n          name=\"from\"\r\n          prefix=\"–\"\r\n          onChange={calculateValue}\r\n          value={fromValue}\r\n        />\r\n      </div>\r\n\r\n      <div className=\"slider-container\">\r\n        <CurrencySlider\r\n          wallets={wallets}\r\n          current={toWallet}\r\n          onChange={(to: string) => dispatch(setWallets([fromWallet, to]))}\r\n        />\r\n\r\n        <CurrencyInput disabled name=\"to\" prefix=\"+\" value={toValue} />\r\n      </div>\r\n\r\n      <footer className=\"footer\">\r\n        <button\r\n          className=\"btn btn-exchange\"\r\n          disabled={!fromValue || fromWallet === toWallet}\r\n          onClick={() => {\r\n            dispatch(exchangeValue(fromValue));\r\n            setFromValue(0);\r\n            setToValue(0);\r\n          }}\r\n        >\r\n          Exchange\r\n        </button>\r\n      </footer>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default Exchange;\r\n","import React from \"react\";\nimport Exchange from \"./features/exchange/Exchange\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"container\">\n      <div className=\"wrapper\">\n        <Exchange />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport exchangeReducer from '../features/exchange/exchangeSlice';\n\nexport const store = configureStore({\n  reducer: {\n    exchange: exchangeReducer,\n  },\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}